name: Build and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_DEFAULT_REGION: "ap-southeast-2"
  NODE_VERSION: "20"
  STACK_NAME: "CipherProjectsStack"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Next.js Dependencies
        run: npm ci

      - name: Create ESLint config
        run: |
          echo '{
            "extends": "next",
            "rules": {
              "react/no-unescaped-entities": "off",
              "@next/next/no-img-element": "off"
            }
          }' > .eslintrc.json

      - name: Run ESLint
        run: |
          npm run lint || true
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Install CDK Dependencies
        working-directory: cipher-infra
        run: |
          npm ci
          npm install -g aws-cdk

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Build Next.js
        run: npm run build

      - name: Package Application
        run: |
          zip -r deploy.zip .next package.json package-lock.json public next.config.js app pages
          echo "Created deploy.zip with contents:"
          unzip -l deploy.zip

      - name: Deploy Infrastructure
        working-directory: cipher-infra
        run: |
          echo "Checking user-data.sh existence:"
          ls -l lib/user-data.sh
          cdk deploy --require-approval never || {
            echo "CDK deployment failed. Checking CloudFormation events..."
            aws cloudformation describe-stack-events --stack-name ${{ env.STACK_NAME }} --query 'StackEvents[?ResourceStatus==`CREATE_FAILED`].[LogicalResourceId,ResourceStatusReason]' --output text
            exit 1
          }

      - name: Get Stack Outputs
        id: stack-outputs
        run: |
          echo "=== Stack Outputs ==="
          STACK_OUTPUT=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs' --output json)
          echo "$STACK_OUTPUT"
          
          BUCKET_NAME=$(echo "$STACK_OUTPUT" | jq -r '.[] | select(.OutputKey=="DeploymentBucketName") | .OutputValue')
          EC2_ID=$(echo "$STACK_OUTPUT" | jq -r '.[] | select(.OutputKey=="InstanceId") | .OutputValue')
          
          echo "DEPLOY_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
          echo "EC2_INSTANCE_ID=$EC2_ID" >> $GITHUB_ENV
          
          echo "Found bucket name: $BUCKET_NAME"
          echo "Found EC2 instance ID: $EC2_ID"

      - name: Wait for Bucket
        run: |
          echo "Waiting for bucket ${{ env.DEPLOY_BUCKET }} to be accessible..."
          for i in {1..30}; do
            if aws s3api head-bucket --bucket ${{ env.DEPLOY_BUCKET }} 2>/dev/null; then
              echo "Bucket is accessible"
              break
            fi
            echo "Attempt $i: Bucket not ready, waiting..."
            sleep 10
          done

      - name: Upload to S3
        run: |
          echo "Uploading deploy.zip to s3://${{ env.DEPLOY_BUCKET }}/"
          aws s3 cp deploy.zip "s3://${{ env.DEPLOY_BUCKET }}/deploy.zip" || {
            echo "Upload failed. Checking bucket permissions..."
            aws s3api get-bucket-policy --bucket ${{ env.DEPLOY_BUCKET }}
            exit 1
          }

      - name: Wait for Instance
        run: |
          echo "Waiting for EC2 instance ${{ env.EC2_INSTANCE_ID }} to be ready..."
          aws ec2 wait instance-status-ok --instance-ids ${{ env.EC2_INSTANCE_ID }}

      - name: Deploy to EC2
        run: |
          echo "Deploying to EC2 instance ${{ env.EC2_INSTANCE_ID }}..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=instanceids,Values=['${{ env.EC2_INSTANCE_ID }}']" \
            --parameters 'commands=[
              "cd /var/www/cipher-projects",
              "aws s3 cp s3://${{ env.DEPLOY_BUCKET }}/deploy.zip .",
              "unzip -o deploy.zip",
              "chown -R webadmin:webadmin .",
              "su - webadmin -c \"cd /var/www/cipher-projects && npm ci --production\"",
              "su - webadmin -c \"cd /var/www/cipher-projects && pm2 restart cipher-projects || pm2 start npm --name \"cipher-projects\" -- start\""
            ]' \
            --output text

      - name: Verify Deployment
        run: |
          echo "Deployed to EC2 instance: ${{ env.EC2_INSTANCE_ID }}"
          echo "CloudFront domain: $(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDomain`].OutputValue' --output text)"
          
          # Wait for application to be accessible
          for i in {1..30}; do
            if curl -sf http://$(aws ec2 describe-instances --instance-ids ${{ env.EC2_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicDnsName' --output text) > /dev/null; then
              echo "Application is responding"
              break
            fi
            echo "Waiting for application to start... (attempt $i/30)"
            sleep 10
          done